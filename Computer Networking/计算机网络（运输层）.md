enxi# > 计算机网络（运输层）

> ## 一、概述
>
> > 1.运输层功能
> >
> > - 运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）
> > - 运输层还要对收到的报文进行差错检测
> > - 运输层需要有两种不同的运输协议，即面向连接的 **TCP** 和无连接的 **UDP**
> >
> > 2.运输层的两个主要协议
> > TCP/IP 的运输层有两个不同的协议：
> >
> > - **用户数据报协议 UDP**(User Datagram Protocol)
> > - **传输控制协议 TCP**(Transmission Control Protocol)
> >
> > UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。
> >
> > TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。
> >
> > TCP和UDP最基本的责任是：将两个端系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机交付扩展到进程间交付被称为运输层的多路复用与多路分解。
>
> ## 二、多路复用与多路分解
>
> > 1.多路复用与多路多路分解
> >
> > **主机将一个到达运输层报文段定向到适当套接字的过程**：每个运输层报文段中具有几个字段，在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字。**在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息(用于以后分解)从而生成报文段，然后将这些报文段传递到网络层，这些工作叫多路复用**，**将运输报文段中的数据交付到正确的套接字的工作称为多路分解**
> >
> > 2.面向无连接的多路复用与多路分解
> >
> > 在运输层，无连接的网络传输是通过UDP来实现的。UDP报文中只有源端口号和目的端口号，一个UDP套接字是由一个含有目的IP地址和目的端口号的二元组来全面标识的。在客户端，源端口号是客户进程套接字的端口号，目的端口号是服务器的端口号。而在服务器端，源端口号是服务器的创建的套接字的端口号，而目的端口号是客户端的套接字的端口号。
> >
> > 注意：我们看到使用UDP来传输报文段时，一个UDP套接字是由一个含有目的IP地址和目的端口号的二元组来全面标识的。因此，如果两个UDP报文段有不同的源IP地址和源端口，但具有相同的IP地址和目的端口号，那么这两个报文段将通过相同的目的端口号定向到相同的目的进程。
> >
> > 3.面向连接的多路复用与多路分解
> >
> > 网络上主机间的进程间通信，实质上是通过套接字来实现的。在运输层中面向连接的网络传输多使用TCP，而TCP套接字和UDP套接字之间有一个细微的差别，就是，TCP套接字是由一个四元组（源IP地址、源端口号，目的IP地址，目的端口号）来标识的。这样，当一个TCP报文段从网络到达一台主机时，主机会使用全部4个值来将报文段定向，即多路分解到相应的套接字。
> >
> > 注意：与UDP不同的是，两个具有不同源IP或源端口号的TCP报文段将被重定向到两个不同的套接字。对于一个TCP服务器，当它接受一个连接时，它会产生一个新的套接字，然后通过新的套接字来与客户端通信，也就是通过新的套接字来把数据发送回给客户端。由于每一个连接都会产生一个新的套接字，所以具有不同的源IP或源端口号的连接就是一个不同的连接，对应着产生的新的不同的套接字。
>
> ## 三、UDP（面向无连接）
>
> > 1.UDP的主要特点：
> >
> > - **UDP 是无连接的**，即发送数据之前不需要建立连接。
> > - **UDP 使用尽最大努力交付**，即不保证可靠交付，同时也不使用拥塞控制
> > - **UDP 是面向报文的**
> > - **UDP 没有拥塞控制**，很适合多媒体通信的要求。
> > - **UDP 支持一对一、一对多、多对一和多对多的交互通信**
> > - **UDP 的首部开销小**，只有 8 个字节

> > 2.UDP提供不可靠服务时，具有TCP所没有的优势：
> >
> > * UDP无连接且分组首部开销小，时间上不存在建立连接需要的时延。空间上，TCP需要在端系统中维护连接状态，需要一定的开销。UDP不维护连接状态，也不跟踪这些参数，开销小。空间和时间上都具有优势。
> >
> > * UDP没有拥塞控制，应用层能够更好的控制要发送的数据和发送时间，网络中的拥塞控制也不会影响主机的发送速率。
> >
> >   注意：如果每个人都启动流式高比特率视频而不使用任何拥塞控制的话，就会使路由器中有大量的分组溢出，伴随着拥塞，TCP的发送速率也会被降低。UDP中缺乏拥塞控制能够导致UDP发送方和接收方之间的高丢包率，并挤跨TCP会话
> >
> > * UDP是面向报文的，对应用层交下来的报文，添加首部后直接乡下交付为IP层，既不合并，也不拆分，保留这些报文的边界。
> >
> > 3.UDP报文结构
> >
> > ![UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，
> > 1.**源端口**： 源端口号，需要对方回信时选用，不需要时全部置0.
> > 2.**目的端口**：目的端口号，在终点交付报文的时候需要用到。
> > 3.**长度**：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）
> > 4.**校验和**：检测UDP数据报在传输中是否有错，有错则丢弃。
> > 该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0.
> > 当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交给应用进程。
> > 如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0,），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。](https://img-blog.csdnimg.cn/20181226160325166.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FhMTkyODk5Mjc3Mg==,size_16,color_FFFFFF,t_70)
> >
> > UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，
> > 1.**源端口**： 源端口号，需要对方回信时选用，不需要时全部置0.
> > 2.**目的端口**：目的端口号，在终点交付报文的时候需要用到。
> > 3.**长度**：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）
> > 4.**校验和**：检测UDP数据报在传输中是否有错，有错则丢弃。如果接收方UDP发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程0），就丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。（发送方的UDP对报文段中所有的16比特字的和进行反码运算，求和时遇到任何溢出都回卷。在接收方将收到的所有比特字加在一起，这里包括检验和，如果该分组中没有引入差错，则接收方的该和应当全是1，如果出现0说明该分组出现差错）
>
> ## 四、可靠数据传输
>
> >1.构造可靠的传输协议
> >
> >> 1.经完全可靠的信道的可靠数据传输：rdt1.0
> >>
> >> * 不会发生错误
> >> * 不会丢弃分组
> >>
> >> 主要有传输端与接收端两个部分，资料传输方式很单纯，传输端等待上层传资料进来，收到上面的资料以后装成封包送出去。接收端收到封包以后，将封包解开，把讯息往上送。
> >>
> >> Rdt1.0的缺陷：
> >>
> >> * 利用校验和检测位错误
> >>
> >> Rdt1.0改进（应对错误）：
> >>
> >> * ACK：接收方显式的告知发送分组已经正确接收
> >> * NAK：接收方显式的告知发送方分组有错
> >> * 发送方收到NAK后，重传分组
> >
> >2.经具有比特差错信道的可靠数据传输：rdt2.0
> >
> >> * 差错检测
> >> * 接收方反馈控制信息：ACK/NAK
> >> * 重传
> >>
> >> 基于这样的重传机制的可靠数据传输协议称为自动重传请求协议（ARQ）
> >>
> >> 当发送方处于等待ACK或NAK的状态时，他不能从上层获取更多的数据。这就是说，rdt_send（）事件不可能出现；仅当接收到ACK并离开该状态时才能发生这样的事件，因此，发送方将不会发送一块新数据，除非发送方确信接收方已经正确接收当前分组。由于这种行为，rdt2.0被称为停等协议
> >>
> >> 
> >
> >3.rdt2.1
> >
> >> 解决重复分组与ACK/NAK消息发生错误的问题
> >>
> >> 但是rdt 2.0没有考虑到ACK或NAK分组受损的可能性，解决这个问题的方法(几乎所有现有的数据传输协议中，包括TCP都采用)是在数据分组中添加一个新字段，让发送方对其数据分组编号，即将发送数据分组的**序号**放在该字段，于是接收方只需要检查序号即可确定收到的分组是否需要一次重传。当接收到失序分组时，接收方对所接受的分组发送一个肯定确认。如果收到受损分组，则接收方将发送一个否定确认。如果不发送NAK，而是对上次正确接收的分组发送一个ACK（即接收到冗余ACK）后，就知道没有正确接收到跟在被确认两次的分组后的分组。
> >>
> >> 4、rdt2.2
> >> rdt2.2是在rdt2.1上的基础之上做了小小的改善，摒弃了NAK，只需采用ACK。我们在ACK的信息上加上了期望的顺序号，现在假设情景发送方向接收方发送0号数据包，如果接收方接收到0号数据包，返回（ACK，1），发送方接着发送1号数据包。如果接收方接收到0号数据包出现错误，返回（ACK，0），发送方重传0号数据包。
> >
> >5.经具有比特差错的丢包信道的可靠数据传输：rdt3.0
> >
> >> 3.0同时考虑到封包遗失与资料错误的情形，除了使用ACK机制，另外在传送端多了倒数计时器，封包送出去如果超过时间仍未收到ACK或是收到不正确编号的ACK，则再送出封包一次。
> >>
> >> 缺陷：rdt3.0是一个功能正确的协议，但是它的性能却很差，rdt3.0的性能问题的核心在于它是一个停等协议。
> >>
> >> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200815092703805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0MTA5NA==,size_16,color_FFFFFF,t_70#pic_center)
> >
> >6.流水线可靠传输数据协议
> >
> >> 在今天的高速网络中，rdt 3.0性能问题的核心在于它是一个停等协议，受到这个机制本身的影响，需要更好的传输协议。流水线技术是解决这种特殊性能问题的一个非常简单的方法：不使用停等方式运行，允许发送端发送多个分组而无需等待确认。
> >>
> >> 虽然流水线可以直线提升 rdt 3.0 协议的性能，但是也会带来如下的影响：
> >>
> >> - 必须增加序号的范围。因为每个传输中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在输送中尚未确认的分组
> >> - 协议的发送端和接收端也必须缓存多个分组。发送方最低限度应当能缓冲那些已发送但没有确认的分组，接收方或许也需要缓存那些已正确接收的分组
> >> - 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏和延时过大的分组。
> >>
> >> 解决流水线的差错恢复有两种基本方法，分别为 **回退 N 步（Go-Back-N, GBN）** 和 **选择重传（Selective Repeat, SR）**。
> >>
> >> GBN协议
> >>
> >> 传输多个封包 必须有个暂存的区域，暂存的区域中存在着窗格大小(Window Size) N，存放着各种封包(已确认、已送出但未收到ACK、未送出的封包等等)。接收端也会开启窗格来接收封包，会记着目前收到封包的编号，假设收到顺序不对的封包N+1(等待接收第N个，下一个传来的却是第N+1号)，会将N以后的封包全部丢弃，此时传送端一直没收到ACK(N)，会把N号以后的封包全部重新传送出去。
> >>
> >> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200815101708330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU0MTA5NA==,size_16,color_FFFFFF,t_70#pic_center)
> >>
> >> ![img](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2358821438,1240211363&fm=15&gp=0.jpg)
> >>
> >> SR协议
> >>
> >> GBN的传送方法往往会造成不必要的重复，因此SR的传送方法就是只针对未收到的封包做重新传输的动作。首先规划出大小为N的窗格来限制大小，窗格的基底会停留在最近一个尚未收到ACK的封包区域，当封包时间逾时会重新送出封包，直到收到该封包的ACK 窗格基底才会往前移动。（不采用累计确认，接收端维护一个缓存）
> >>
> >> 
> >>
> >> ![img](https://img-blog.csdn.net/20131221210033265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHBwcmluY2U=/font/5a6L5L2T/fontsize/400
