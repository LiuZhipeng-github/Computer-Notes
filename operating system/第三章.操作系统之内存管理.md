# 一、一种存储抽象（地址空间）

## 1. 内存管理的概述

操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢?

> 1. 操作系统负责内存空间的分配与回收。
> 2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充。
> 3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换。
> 4. 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

### 1.1 内存空间的分配与回收

内存空间的分配与回收：由**操作系统完成主存储器空间的分配和管理**，使程序员摆脱存储分配麻烦，提高编程效率。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70.png)

### 1.2 内存空间的扩展

内存空间的扩充：利用虚拟存储技术或者自动覆盖技术，从逻辑上扩充内存。

> 游戏GTA的大小超过60GB，按理来说这个游戏程序运行之前需要把60GB数据全部放入内存。然而，实际我的电脑内存才4GB， 但为什么这个游戏可以顺利运行呢?
> –虚拟技术(操作系统的虚拟性)

### 1.3 地址转换

地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理器必须提供地址变换功能，把逻辑地址转换成相应的物理地址。

为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换(这个过程称为地址重定位(三种装入方式))应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164118000.png)

### 1.4 内存保护

存储保护：保证各道作业在各自的存储空间内运行，互不干扰。

两种方式：

> 1.CPU中设置一对上，下限寄存器，存放用户作业在主存中的下限和上限，每当CPU要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。
>
> 2.通过采用重定位寄存器（或基址寄存器）和界地址寄存器（又称限长寄存器）来实现这种保护，重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值，每个逻辑地址值必须小于界地址寄存器，内存管理机构动态的将逻辑地址与界地址寄存器进行比较，如果未发生地址越界。则加上重定位寄存器的值后映射成物理地址，再送交内存单元。
> ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164149065.png)
> ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164157985.png)

### 1.5 总结

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164238238.png)

### 

## 2.进程运行的基本原理(从写程序到程序运行)

编译：由编译程序将用户源代码编译成若千个目标模块(编译就是把高级语言翻译为机器语言)

链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块

装入(装载) :由装入程序将装入模块装入内存运行（重定位时只更改目标程序中指令和数据）

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164316636.png)

### 2.1 装入内存的三种方式

1. 绝对装入:在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。
   **绝对装入由于逻辑与实际内存地址相同**，故不需要对程序和数据的地址进行修改。绝对装入只适用于单道程序环境，绝对地址可由程序员在编译或者汇编时赋予。
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164330113.png)
2. 可重定位装入：（在程序运行之前就将程序内的地址给改掉）在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时采用可重定位装入方式，根据内存的目前情况，将装入模块装入到内存的适当位置。**装入时对目标程序中指令和数据的修改称为重定位**，地址变换通常是在装入时一次完成的（因此装入之后不能再更改地址）。所以又称静态重定位。
   静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业，此外，作业一旦进入内存后，在整个运行期间不能在内存中移动。
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164336410.png)
3. **动态运行时装入**：（每次执行指令时动态的将程序内地址加上基址）也称为动态重定位，程序在内存中如果发生移动，就需要采用动态的装入方式。编译、链接后的装入模块的地址都是从0开始的。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换成绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。
   动态重定位的特点是可以将程序分配到不连续的存储区中，在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配的内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164342795.png)
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164348442.png)

### 2.2 链接的三种方式

1. 静态链接:在程序运行之前，先将各目标模块及它们所需的库函数连接成-一个完整的可执行文件(装入模块)，之后不再拆开。
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164405422.png)
   2.装入时动态链接：将用户源程序编译后所得到的一组目标模块，将各目标模块装入内存时，边装入边链接的链接方式。
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164410609.png)
   3.运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接，其优点是便于修改和更新，便于实现对目标模块的共享。
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164417178.png)



## 3. 内存的覆盖与交换

### 3.1 覆盖技术

由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成为一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调如覆盖区，替换覆盖区中原有的段。

覆盖技术的特点：是打破了必须将一个进程的全部信息装入内存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。

> 早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题
> 覆盖技术的思想:将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。
> 内存中分为一个“固定区”和若干个“覆盖区”。
> 需要常驻内存的段放在“固定区”中，调入后就不再调出(除非运行结束)
> 不常用的段放在“覆盖区”,需要用到时调入内存，用不到时调出内存
> ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164426832.png)
> 必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点:对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。

### 3.2 交换技术

**交换(对换)技术的设计思想**：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)

> 换入：把准备好竞争CPU运行的程序从辅存移到内存。
> 换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。
> ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164435629.png)
> 暂时换出外存等待的进程状态为挂起状态(挂起态，suspend)，挂起态又可以进–步细分为就绪挂起、阻塞挂起两种状态。
> ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164442142.png)

1. 应该在外存(磁盘)的什么位置保存被换出的进程?
   答：具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。
2. 什么时候应该交换?
   答：交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。
3. 应该换出哪些进程?
   答：可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…
   (注意: PCB 会常驻内存，不会被换出外存)

**注意：**

> 1. 交换需要备份存储，通常是快速磁盘，它必须足够大，并且提供对这些内存映像的直接访问。
> 2. 为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间，转移时间与所交换的空间内存成正比。
> 3. 如果换出进程，比如确保该进程的内存空间成正比。
> 4. 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。
> 5. 交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。
> 6. 普通交换使用不多，但交换的策略的某些变种在许多系统中（如UNIX系统）仍然发挥作用。

**交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中。**

### 3.3 总结

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164505513.png)



# 二、基本内存管理

## 1.分区（连续分配管理方式）

### 1. 静态分区分配

#### 1.1 单一连续分配

内存在此方式下分为系统区和用户区。
系统区仅提供给操作系统使用，通常在低地址部分；
用户区是为用户提供的，除系统区之外的内存空间，我们平常运行的软件都在用户区里分配空间。

> 优点：无外部碎片，可以采用覆盖技术，不需要额外技术支持。
> 缺点：只能用于单用户，单任务操作系统中，有内部碎片，存储器利用率极低。

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164517253.png)

#### 1.2 固定分区分配

固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后背作业队列中，选择适当大小的作业装入该分区，如此循环。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164530689.png)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164543779.png)

> 1. 分区大小相等：用于利用一台计算机控制多个相同对象的场合，缺乏灵活性
> 2. 分区大小不等：划分为含有多个较小的分区，适量的中等分区及少量的大分区。
>    **优点**：1.没有外部碎片
>    **缺点**：1.程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间。
> 3. 主存利用率低，当程序小于固定分区大小时，也占用一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为内部碎片。
> 4. 不能多个进程共享一个主存区

### 2. 动态分区分配

#### 2.1 分配

**动态分区分配又称为可变分区分配**，是一种动态划分内存的分区方法。这种分配方式不会预先划分内存分区，而是在进程装入内存时, 根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg: 假设某计算机内存大小为64MB， 系统区8MB，用户区共56 M…)
!![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164551233.png)
**缺点**：外部随便很多（通过紧凑消除，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器地支持，且相对费时。紧凑地过程实际上类似于Windows系统中地磁盘整理程序，只不过后者是对外存空间地紧凑）

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164558669.png)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164606250.png)

#### 2.2 动态分区分配算法

> 1.首次适应算法
> 2.最佳适应算法
> 3.最坏适应算法
> 4.邻近适应

##### 首次适应算法

算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。

如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164616957.png)

##### 最佳适应算法

算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。

如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164625289.png)

##### 最坏适应算法

又称最大适应算法(Largest Fit)

算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164642276.png)

##### 邻近适应算法（快速适配）

算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164650355.png)

#### 2.3 算法总结

首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。

最佳导致大量碎片，最坏导致没有大的空间。

进过实验，首次适应比最佳适应要好，他们都比最坏好。

| 算法     | 算法思想                                           | 分区排列顺序                                 | 优点                                                         | 缺点                                                         |
| -------- | -------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | 从头到尾找适合的分区                               | 空闲分区以地址递增次序排列                   | 综合看性能最好。**算法开销小**，回收分区后一.般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区               | 空闲分区以容量递增次序排列                   | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的、难以利用的碎片;**算法开销大**，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片   | 空闲分区以容量递减次序排列                   | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程;**算法开销大**(原因同上)      |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列(可排列成循环链表) | 不用每次都从低地址的小分区开始检索。**算法开销小**(原因同首次适应算法) | 会使高地址的大分区也被用完                                   |

### 3.连续式分配的缺陷

#### 3.1 连续分区分配方式的缺点

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164700933.png)

#### 3.2 把"固定分区分配"改成"非连续分配版本"

**非连续分配管理**：

> 需要额外地空间存储（分散区域）地索引，使得非连续分配地方式存储密度低于连续存储方式。
> 根据分区大小是否固定分为分页存储管理方式和分段存储管理方式。

根据分配时所采用的基本单位不同，可将离散分配的管理方式分为以下三种：
页式存储管理、段式存储管理、段页式存储管理。其中段页式存储管理是前两种结合的产物。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164707835.png)
**根据分区大小是否固定分为分页存储管理方式和分段存储管理方式。**

### 4. 总结

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164716156.png)

## 2.分段（非连续式分配）

#### 2.1 分段

进程的地址空间:按照程序自身的逻辑关系划分为若千个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，**每段从0开始编址，每个段也可以独立的增大或者减小而不会影响其他的段**

![88D48273-4AAC-4A84-BAE3-F854366230F3_1_105_c](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/88D48273-4AAC-4A84-BAE3-F854366230F3_1_105_c.jpeg)

内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164728877.png)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164739652.png)

#### 2.2 段表

问题:程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立- -张段映射表，简称“段表”
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164747244.png)

#### 2.3 地址转换

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164754459.png)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164801431.png)

## 3.分页（非连续式分配）

### 3.1 基本分页存储管理的基本概念

在前面的几种存储管理方法中，为进程分配的空间是连续的，使用的地址都是物理地址。如果允许将一个进程分散到许多不连续的空间，就可以避免内存紧缩，减少碎片。基于这一思想，通过引入进程的逻辑地址，把进程地址空间与实际存储空间分离，增加存储管理的灵活性。

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164809123.png)

分页的方法形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片，但它又又本质不同点：块的大小相对分区要小很多，而且进程页按照块进行划分，进程运行时按块申请主存可用空间执行。每个进程平均只产生半个块大小的内部碎片（也称页内碎片）

进程中的块称为页，内存中的块称为页框（页帧），外存页以同样的单位进行划分，直接称为块。
页面过小页表占用空间大，页面过大，碎片大。

页式管理只需要给出一个整数就能确定对应的物理地址，这是因为页面大小L是固定的，因此，页式管理中地址空间是一维空间。

### 3.2 页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立–张页表。页表：逻辑地址+物理地址+合法位（保护位）

![img](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/58392bf5841f6.png)


#### 

### 3.3 地址转换过程及程序内地址转换（前面的动态重定位是连续分区时，这边的动态重定位是不连续分区）

**动态重定位是整个模块进行重定位（连续），而分页则是按页装入内存（不连续）**

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

注意:页面大小是2的整数幂
设页面大小为L，逻辑地址A到物理地址E的变换过程如下:
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164832846.png)

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164839114.png)
**如下图：当采用分页进行内存分配时，程序内的地址如何转化。注意：这里不是算对页面的寻址哦**
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164845792.png)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164852247.png)

### 3.4 逻辑地址结构与计算（页面寻址）

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164902401.png)

如何计算:
页号=逻辑地址/页面长度(取除法的整数部分)
页内偏移量=逻辑地址%页面长度(取除法的余数部分)(为了方便计算页号、页内偏移量 重页面大小一般要为2的整数幂)

> 假设用32个二进制位表示逻辑地址，页面大小为2^12 B = 4096B = 4KB
>
> 0号页的逻辑地址空间应该是0~4095，用二进制表示应该是:
> 0000 0000 0000 0000 0000 0000 0000 0000 ~ 0000 0000 0000 0000 0000 1111 1111 1111
>
> 1号页的逻辑地址空间应该是4096~8191， 用二进制表示应该是:
> 0000 0000 0000 0000 0001 0000 0000 0000 ~ 0000 0000 0000 0000 0001 1111 1111 1111
>
> 2号页的逻辑地址空间应该是8192~12287， 用二进制表示应该是:
> 0000 0000 0000 0000 0100 0000 0000 0000 ~ 0000 0000 0000 0000 0101 1111 1111 1111
>
> Eg:逻辑地址2，用二进制表示应该是0000 0000 0000 0000 0000 0000 0000 0010
> 若0号页在内存中的起始地址为X，则逻辑地址2对应的物理地址应该是X+0000 0000 0100
> 与另一种算法的结果对比：页号=逻辑地址/页面长度，页内偏移量=逻辑地址%页面长度
>
> Eg:逻辑地址4097,用-二进制表示应该是 0000 0000 0000 0000 0001 0000 0000 0001
> 若1号页在内存中的起始地址为X，则逻辑地址4097 对应的物理地址应该是X+0000 0000 0001

> 假设用32个二进制位表示逻辑地址，页面大小为2^10 B = 1024B = 1KB
>
> 0号页的逻辑地址空间应该是0~1023，用二进制表示应该是:
> 0000 0000 0000 0000 0000 0000 0000 0000 ~ 0000 0000 0000 0000 0000 0011 1111 1111
>
> 1号页的逻辑地址空间应该是1024~2047， 用二进制表示应该是:
> 0000 0000 0000 0000 0000 0100 0000 0000 ~ 0000 0000 0000 0000 0000 0111 1111 1111
>
> 2号页的逻辑地址空间应该是2048~3021， 用二进制表示应该是:
> 0000 0000 0000 0000 0000 1000 0000 0000 ~ 0000 0000 0000 0000 0000 1011 1100 1101

结论:如果每个页面大小为2^K B，用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号
因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190606085431658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70)
例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。
等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。

> ①计算页号、页内偏移量
> 页号P=A/L = 2500/1024 = 2; 页内偏移量W= A%L = 2500%1024 = 452
>
> ②根据题中条件可知，页号2没有越界，其存放的内存块号b=8
>
> ③物理地址E=b*L+W=8 * 1024+ 425 = 8644
>
> 在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是-维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

### 3.5 分页中的两个核心问题

#### 3.5.1、虚拟地址到物理地址的映射必须非常快。—TLB（快表）

##### 3.5.1.1 局部性原理（快表的由来）

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164918830.png)

##### 3.5.1.2 什么是快表

快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164929787.png)

##### 3.5.1.3 引入快表后，地址的转换过程

> ①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。
> ③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)

由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。
因为局部性原理，–般来说快表的命中率可以达到90%以上。

例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问- -次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?
(1+100) * 0.9 + (1+100+100) * 0.1 = 111 us
有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1+100) * 0.9+ (100+100) *0.1=110.9 us
若未采用快表机制，则访问一个逻辑地址需要100+100 = 200us
显然，引入快表机制后，访问一个逻辑地址的速度快多了。

##### 3.5.1.4 总结

|                        | 地址变换过程                                                 | 访问一个逻辑地址的访存次数                      |
| ---------------------- | ------------------------------------------------------------ | ----------------------------------------------- |
| 基本地址变换机构       | ①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元 | 两次访存                                        |
| 具有快表的地址变换机构 | ①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元 | 快表命中，只需一次访存 快表未命中，需要两次访存 |

#### 3.5.2 如果虚拟地址空间很大，页表也会很大。—多级页表

##### 3.5.2.1 单级页表的问题

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164940470.png)
根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了，因此没有必要让整个页表都常驻内存。

##### 3.5.2.2 如何解决单级页表的问题

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164948356.png)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121164955939.png)

##### 3.5.2.3 两级页表的原理、地址结构

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165001130.png)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165007039.png)

##### 3.5.2.4 如何实现地址转换

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165013905.png)

##### 3.5.2.5 需要注意的问题

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165021036.png)

##### 3.5.2.6 总结

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165027955.png)

#### 3.5.3 TLB与多级列表的实现

![TLB与多级页表](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/TLB%E4%B8%8E%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8.png)



### 3.6 分段、分页管理的对比

#### 3.6.1 对比

1. 页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理.上的需要，完全是系统行为，对用户是不可见的。段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。-一个段通常包含着一-组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。
2. 页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。
3. 在分段的方法中，每次程序运行时总是把程序全部装入内存，而分页的方法则有所不同。分页的思想是程序运行时用到哪页就为哪页分配内存，没用到的页暂时保留在硬盘上。当用到这些页时再在物理地址空间中为这些页分配内存，然后建立虚拟地址空间中的页和刚分配的物理内存页间的映射。
4. 分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165038089.png)
5. 分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码(不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165049212.png)
   ![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165058930.png)
   **访问一个逻辑地址需要几次访存?**
   分页(单级页表) :第一次访存–查内存中的页表，第二次访存一-访问目标内存单元。总共两次访存
   分段:第一次访存–查内存中的段表，第二次访存–访问目标内存单元。总共两次访存
   与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一.次访问，加快地址变换速度。

#### 3.6.2 总结

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165105952.png)

### 3.7 段页式管理方式

#### 3.7.1 分页、分段的优缺点分析

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165111157.png)

#### 3.7.2 分段+分页=段页式管理

​    **程序    ——虚拟内存——物理内存**

**逻辑地址——虚拟地址——物理地址**

![段页式1](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/%E6%AE%B5%E9%A1%B5%E5%BC%8F1.png)

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165122589.png)
将进程按逻辑模块分段，再将各段分页(如每个页面4KB )再将内存空间分为大小相同的内存块/页框/页帧/物理块进程前将各页面分别装入各内存块中

#### 3.7.3 段页式管理的逻辑地址结构

![2019060609051043](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/2019060609051043.png)

#### 3.7.4 段页式访问流程

![20190606090525810](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606090525810.png)

![20190606090541487](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606090541487.png)

#### 3.7.5 总结

![20190606090557233](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606090557233.png)

## 三、虚拟内存

## 1. 虚拟内存的基本概念

### 1.1 传统存储管理方式的特征、缺点

![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165150953.png)
一次性（可用虛拟存储技术解决问题）：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题:①作业很大时，不能全部装入内存，导致大作业无法运行;②当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。
驻留性:一旦作业被装入内存，就会- 直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一-小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。                                                                                                                               

### 1.2 虚拟内存的定义和特征

基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。
在程序执行过程中，当所访问的信息不在内存时， 由操作系统负责将所需信息从外存调入内存，然后继续执行程序。
若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。
在操作系统的管理下，在用户看来似乎有-一个比实际内存大得多的内存，这就是虚拟内存(操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑.上进行了扩充)

易混知识点:
虚拟内存的最大容量是由计算机的地址结构(CPU寻址范围)确定的
虚拟内存的实际容量= min (内存和外存容量之和，CPU寻址范围)

如:某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。
则虚拟内存的最大容量为2^32 B = 4GB
虚拟内存的实际容量= min (2^32 B, 512MB+2GB) = 2GB+512MB

虚拟内存有以下三个主要特征

> **多次性**：无需在作业运行时一次性全部装入内存，二十运行被分成多次调入内存
> **对换性**：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，讲作业换出、换入。
> **虚拟性**：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量

### 1.3 如何实现虚拟内存技术

虚拟内存中，允许将一个作业分多次调入内存，采用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量，因此,虚拟内存的实现需要建立在离散分配的内存管理方式基础上。

传统的非连续分配存储管理:

> 1. 基本分页存储管理
> 2. 基本分段存储管理
> 3. 基本段页式存储管理

虚拟内存的实现有以下三种方式：

> 1.请求分页存储管理
> 2.请求分段存储管理
> 3.请求段页式存储管理

请求分页系统建立在基本分页系统的基础上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种虚拟存储器方法。

主要区别：

在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(操作系统要提供请求调页(或请求调段)功能)，然后继续执行程序。
若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存(操作系统要提供页面置换(或段置换)的功能)。

#### 

## 2. 请求分页管理方式

### 2.1 页表机制

与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存;如果还没调入，那么也需要知道该页面在外存中存放的位置。

当内存空间不够时，要实现“页面置换” 操作系统需要通过某些指标来决定到底换出哪个页面;有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。
![页表项](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/%E9%A1%B5%E8%A1%A8%E9%A1%B9.jpg)

> P--位0是存在（Present）标志，用于指明表项对地址转换是否有效。P=1表示有效；P=0表示无效。在页转换过程中，如果说涉及的页目录或页表的表项无效，则会导致一个异常。如果P=0，那么除表示表项无效外，其余位可供程序自由使用，如图所示。例如，操作系统可以使用这些位来保存已存储在磁盘上的页面的序号。
> R/W--位1是读/写（Read/Write）标志。如果等于1，表示页面可以被读、写或执行。如果为0，表示页面只读或可执行。当处理器运行在超级用户特权级（级别0、1或2）时，则R/W位不起作用。页目录项中的R/W位对其所映射的所有页面起作用。
> U/S--位2是用户/超级用户（User/Supervisor）标志。如果为1，那么运行在任何特权级上的程序都可以访问该页面。如果为0，那么页面只能被运行在超级用户特权级（0、1或2）上的程序访问。页目录项中的U/S位对其所映射的所有页面起作用。
> A--位5是已访问（Accessed）标志。当处理器访问页表项映射的页面时，页表表项的这个标志就会被置为1。当处理器访问页目录表项映射的任何页面时，页目录表项的这个标志就会被置为1。处理器只负责设置该标志，操作系统可通过定期地复位该标志来统计页面的使用情况。
> D--位6是页面已被修改（Dirty）标志。当处理器对一个页面执行写操作时，就会设置对应页表表项的D标志。处理器并不会修改页目录项中的D标志。
> AVL--该字段保留专供程序使用。处理器不会修改这几位，以后的升级处理器也不会。



### 2.2 缺页中断过程

缺页中断发生时时间的顺序如下：
1、硬件陷入内核，在堆栈中保存程序技术器。大多数机器将当前的指令的各种状态信息保存在特殊的CPU寄存器中。
2、启动一个汇编代码例程来保存通用寄存器和其他易失的信息，以免被操作系统破坏。这个例程将操作系统作为一个函数来调用。
3、当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面。通常一个硬条件寄存器包了这一信息，如果没有的话，操作系统必须检索程序计数器，取出这条指令，用软件分析这条指令，看看他在缺页中断时正在做什么。
4、一旦知道了发生中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或者杀死进程。如果地址有效且没有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。
5、如果选择的页框脏了，安排该页面写回磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘传输结束。无论如何，该页框被标记为忙，以免因为其他原因而被其他进程占用。
6、一旦页框干净了（无论是立刻还是写回磁盘后），操作系统查找所需页面在磁盘上的地址，通过磁盘操作将其装入。该页面正在装入时，产生缺页中断的进程仍然被挂起，并且如果有其他可运行进程，则选择另一个用户进程运行。
7、当磁盘中断发生时，表明该页已经被装入，页表已经更新可以反映他的位置了，页框也被标记为正常状态。
8、恢复发生缺页中断指令以前的状态，程序计数器重新指向这条指令。
9、调度引发缺页中断的进程，操作系统返回到用他的汇编语言例程。
10、该例程恢复寄存器和其他状态信息，返回到用户空间继续执行，就好像缺页中断从来没有发生过一样。



### 2.3 地址变换机构

请求分页存储管理与基本分页存储管理的主要区别:
在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存(**操作系统要提供请求调页功能，将缺失页面从外存调入内存**)，然后继续执行程序。

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存(**操作系统要提供页面置换的功能，将暂时用不到的页面换出外存**)。
相对于分页系统主要增加了关于状态位P的操作。
![20190606091047573](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606091047573.png)

### 2.4 总结

![20190606091238909](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606091238909.png)

## 3. 页面置换算法

### 3.1 最佳置换法(OPT)

最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。
![20190606091301276](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606091301276.png)
最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的

### 3.2 先进先出置换算法(FIFO)

先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面
实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165229110.png)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165234576.png)
Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差

FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。

### 3.3 最近最久未使用置换算法(LRU)

最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面
实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。
![20190606091415879](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606091415879.png)
在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。

### 3.4 时钟置换算法(CLOCK)

最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。

所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。

时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)

简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165251154.png)



### 3.5 总结

|             | 算法规则                                                     | 优缺点                                          |
| ----------- | ------------------------------------------------------------ | ----------------------------------------------- |
| OPT         | 优先淘汰最长时间内不会被访问的页面                           | 缺页率最小，性能最好;但无法实现                 |
| FIFO        | 优先淘汰最先进入内存的页面                                   | 实现简单;但性能很差，可能出现Belady异常         |
| LRU         | 优先淘汰最近最久没访问的页面                                 | 性能很好;但需要硬件支持，算法开销大             |
| CLOCK (NRU) | 循环扫描各页面 第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。 | 实现简单，算法开销小;但未考虑页面是否被修改过。 |

## 4 .页面分配

### 4.1 页面分配、置换策略

![20190606091545120](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606091545120.png)

![20190606091600555](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606091600555.png)

### 4.2 调入页面的时机

1. 预调页策略：根据局部性原理(主要指空间局部性，即:如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元。)，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测 **成功率只有50%** 左右。故这种策略主要用于进程的首次调入(运行前调入)，由程序员指出应该先调入哪些部分。
2. 请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存(运行时调入)。由这种策略调入的页面一-定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/0操作，因此I/0开销较 大。

### 4.3 从何时调入页面

请求分页系统中外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是采用连续分配方式，而文件区采用离散分配方式，故对换区的磁盘I/O速度比文件区的更快。

> 1.系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。
>
> 2.系统缺少足够的对换区空间:凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。
>
> 3.UNIX方式:运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。

![20190606091635828](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/20190606091635828.png)

### 4.4 抖动(颠簸)现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)

为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率
为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集” 的概念

![颠簸](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/%E9%A2%A0%E7%B0%B8.png)

### 4.5 工作集

驻留集:指请求分页存储管理中给进程分配的内存块的集合。
工作集:指在某段时间间隔里，进程实际访问页面的集合。

原理：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动。
![在这里插入图片描述](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5Njc3ODY3,size_16,color_FFFFFF,t_70-20201121165327264.png)
工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如:窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配	······························3个以上的内存块即可满足进程的运行需要。
–般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。
拓展:基于局部性原理可知，进程在–段时间内访问的页面与不久之后会访问的页面是有相关性的。因此，可以根据进程近期访问的页面集合(工作集)来设计- -种页面置换算法- --选择-一个不在工作集中的页面进行淘汰。

### 4.6 清除策略

如果每个页框都被占用，而且被修改过的话，再换入一个新页面时，旧页面首先被写回磁盘。为保证有足够的空闲页框，很多分页系统有一个称为分页守护进程的后台进程，他大多数时候睡眠，但定期被唤醒一检查内存状态。如果空闲框过少，分页守护进程通过预定的页面置换算法选择页面换出内存。如果这些页面被修改过，则将它们写回磁盘。

一种实现清楚策略的方法就是使用双指针时钟。前指针由分页守护进程控制。当他指向一个脏页面时，就把该页面写回磁盘，前指针向前移动。当他指向一个干净页面时，仅仅指针向前移动。后指针用于页面置换，就像在标准时钟算法中一样。现在，由于分页守护进程的工作，后指针命中干净页面的概率会增加。

### 4.7 总结

![2019060609173458](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/2019060609173458.png)

> 1. 虚拟存储只能基于非连续分配技术。
> 2. 虚拟存储器容量既不受外存容量限制，也不受内存容量限制，而是由CPU的寻址范围决定的。
> 3. 在请求分页存储器中，由于页面尺寸增大，存放程序需要的页数就会减少，因此缺页中断的次数也会减少。
> 4. 进程在执行中发生了缺页中断，经操作系统处理后，应让其执行被中断的那一条指令，缺页中断是访存指令引起的，说明所要访问的页面不在内存中，在进行缺页中断处理后，调入所要访问的页面后，访存指令显然应该重新执行。
> 5. 缺页中断调入新页面，肯定要修改页表项和分配页框，同时内存没有页面，需要从外存读入，会发生磁盘I/O。
> 6. 虚拟存储技术是基于程序的局部性原理，局部性越好虚拟存储系统越能更好地发挥其作用。
> 7. 无论采用什么算法，每种页面第一次访问时不可能在内存中，必然发生缺页，所以缺页次数大于程序所需要的页数。
> 8. LRU算法需要对所有的页最近被访问的时间进行记录，查找时间最久的进行替换，这涉及排序，对置换算法而言，开销太大。
> 9. 页表项中合法位信息显示着本页面是否在内存中，也即决定了是否会发生页面故障。
> 10. 虚拟存储扩充内存的基本方法是将一些页或段从内存中调入，调出，而调入，调出的基本手段是覆盖与交换。
> 11. 请求分页存储管理的主要特点是扩充了内存。
> 12. 页式虚拟存储管理的特点是不要求将作业同时全部装入到连续区域，一般只装入10%～30%，不要求将作业装入主存连续区域是所有离散式存储管理（包括页式存储管理）的特点，页式虚拟存储管理需要进行中断处理和页面置换。
> 13. 快表在计算机系统中是用于地址变换。
> 14. 覆盖技术与虚拟存储技术最本质的不同在于覆盖程序段的最大长度要受内存容量大小的限制，而虚拟存储器中的程序最大长度不受内存容量的限制，只受计算机地址结构的限制。另外，覆盖技术中的覆盖段由程序设计，且要求覆盖段中的各个覆盖具有相对独立性，不存在直接联系或相互交叉访问，而虚拟存储技术对用户的程序段之间没有这种要求。
> 15. 交换技术与虚存技术相同点是都要在内存与外存之间交换信息，交换技术与虚存中使用的调入/调出技术主要的区别是：交换技术调入/调出整个进程，因此一个进程大小要受内存容量大小的限制，而虚存中使用的调入/调出技术在内存和外存之间来回传递的是页面或分段，而不是整个进程，从而使得进程的地址映射具有了更大的灵活性，且允许进程的大小比可用的内存空间大。
> 16. 已知系统为32位实地址，采用48位虚地址，页面大小为4KB，页表项大小为8B，假设系统使用纯页式存储，则采用（4）级页表，页内偏移地址（12）位。
>     页面大小为4KB，故页内偏移为12位，系统采用48位虚拟地址，故虚页号48-12=36位。采用多级页表时，最高级页表不能超出一页大小，每页能容纳页表项数位：4KB/8B=512=2^9，36/9=4，故采用4级页表。

## 5.分页的过程

操作系统在下面四个时间段里做与分页相关的操作：进程创建时、进程执行时、缺页中断时和进程终止时。
1、进程创建时：在分页系统中创建一个新进程时，操作系统要确定程序和数据在初始时有多大，并为他们创建一个页表。操作系统还要在内存中为页表分配空间并进行初始化。当进程被换出时，页表不需要驻留在内存中，但当进程运行时，他必须在内存中。另外，操作系统要在磁盘交换区中分配空间，以便在一个进程换出时在磁盘上有放置此进程的空间。操作系统还要用程序正文和数据对交换区进行初始化，这样当新进程发生缺页中断时，可以调入需要的页面。最后操作系统必须把有关页表和磁盘交换区的信息存储在进程表中。
2、当调度一个进程执行时，必须为新进程重置MMU，刷新TLB，以清除以前的进程留下的痕迹。新进程的页表必须成为当前页表，通常可以通过复制该页表或者全部页面装入内存中以减少缺页中断的发生。
3、当缺页中断发生时，操作系统必须通过读硬件寄存器来确定那个虚拟地址造成了缺页中断。通过该信息，计算它需要哪个页面，并在磁盘上对该页面进行定位。他必须找到合适的页框来存放新的页面，必要时，还要置换老的页面，然后把所需的页面读入页框。最后，还要回退程序计数器，使程序计数器指向引起缺页中断的指令，并重新执行该指令。
4、当进程退出的时候，操作系统必须释放进程的页表、页面和页面在硬盘上多占用的空间。如果某些页面是与其他进程共享的，当最后一个使用它们的进程终止时，才可以释放内存和磁盘上的页面。

![操作系统请求分页地址变换流程](%E7%AC%AC%E4%B8%89%E7%AB%A0.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%B5%81%E7%A8%8B.png)

### 重要概念

1.虚拟内存的管理需要有相关硬件和软件的支持
有请求分页页表机制，缺页中断机制，地址变换机构等。

2.在使用交换技术时，如果一个进程正在进行I/O操作时，则不能交换出主存。否则它的I/O数据区将被新换入的进程占用，导致错误，不过可以在操作系统中开辟I/O缓冲区，将数据从外设或将数据输出到外设的I/O活动在系统缓冲区中进行，这时在系统缓冲区与外设I/O时，进程交换不受限制。

3.当程序要访问某个内存单元时，由硬件检查是否允许，如果允许则执行，否则产生地址越界中断。

4.段页式存储管理中，地址映射表是每个进程一张页表，每个段一张段表。

5.内存保护需要由操作系统和硬件机构合作完成，以保证进程空间不被非法访问，内存保护是内存管理的一部分，是操作系统的任务，但是处于安全性和效率考虑，必须由硬件实现，所以需要操作系统和硬件机构的合作来完成。

6.覆盖技术是早期在单一连续存储管理中使用的扩大存储容量的一种技术，它同样也可用于固定分区分配的存储管理者中。

7.分页式存储管理有内部碎片，分段式存储管理有外部碎片，固定分区存储管理方式有内部碎片，分页式存储管理方式有内部碎片。

8.页式存储管理中，页表的始地址存放在寄存器中（页表基址寄存器（PTBR）），这样才能满足在地址变换时，能够较快地完成逻辑地址和物理地址之间的转换。

9.对重定位存储管理方式，应在这个系统中设置一个重定位寄存器。因为系统处理器在通一个时刻只能执行一条指令或访问数据，所以为每道程序（数据）设置一个寄存器是没有必要的，而只需要在切换程序执行时重置寄存器内容即可。

10.采用可重用程序是通过减少对换数的方法来改善系统性能的。可重入程序通过共享来使用同一块存储空间，或者通过动态链接的方式将所需程序映射道相关进程中，其最大的优点是减少了对程序的调入/调出，因此减少了对换数量。

11.实现分页，分段式存储需要特定的数据结构，例如，页表，段表等，为了提高性能还需要提供快存和地址加法器，代价高。分区存储管理满足多道程序设计的最简单存储管理方案，特别适合嵌入式等微型设别。

12.引入覆盖和交换技术是时间换空间。

13.页式存储页面大小是等长的。

14.引入段式存储管理方式，主要是为了满足用户下列要求：方便编程，分段共享，分段保护，动态链接和动态增长

15.主存分配以块为单位，访问以字节为单位。

16.存储管理目的：1方便用户2提高内存利用率

17.分页是一维，分段是二维，因为分页定长。

18.在多个进程并发执行时，所有进程的页表大多数驻留在内存中，在系统中设置一个页表寄存器（PTR），在其中存放页表在内存的起始地址和页表长度，平时，进程未执行时，页表的起始地址和页表长度存放在本进程的PCB中，当调度到进程时，才将两个数据转入页表寄存器，每个进程都有一个单独的逻辑地址，有一张属于自己的页表。

19.段页式存储管理兼有页式管理和段式管理的优点，采用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间，但它的开销比分段式和页式管理的开销都要大。

### 问答

1.为什么要进行内存管理？

单道处理机系统阶段，一个系统一个时间只执行一个程序，内存分配简单。多道程序引入后，进程之间除了共享的不仅仅是处理机，还有主存储器。共享内存比较复杂，此时不对内存进行管理，容易导致数据混乱，以至于限制进程并发执行。

2.页式管理中每个页表项的大小下限如何确定？

首先用总的位数m-页内位数n，得到页号的位数x，然后取log2x，然后对结果向上取正，因为页表项以字节为单位。（也可以选择更大的页表项大小以至于让一个页面能够正好容下整数个页表项以方便存储（例如取成4B，那么一页正好可以装下1K个页表项）或者增加点其他什么信息）

3.多级页表解决了什么问题？又会带来什么问题？

多级页表解决了当逻辑地址空间过大时，页表长度会大大增加的问题。而采用多级页表时一次访盘需要多次访问内存升至磁盘，会大大增加一次方寸的时间。

